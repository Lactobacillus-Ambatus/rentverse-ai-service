<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/rentverse/models/preprocessor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/rentverse/models/preprocessor.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Preprocessing classes that match the notebook implementation.&#10;This module contains the exact same classes used in the notebook to ensure&#10;pickle files can be loaded properly.&#10;&quot;&quot;&quot;&#10;&#10;import pandas as pd&#10;import numpy as np&#10;import re&#10;from sklearn.base import BaseEstimator, TransformerMixin&#10;from sklearn.preprocessing import LabelEncoder&#10;&#10;&#10;class ImprovedDataPreprocessor(BaseEstimator, TransformerMixin):&#10;    &quot;&quot;&quot;&#10;    Simplified and robust data preprocessor for real estate data with aggressive outlier removal.&#10;    This is the exact same class from the notebook to ensure pickle compatibility.&#10;    &quot;&quot;&quot;&#10;    &#10;    def __init__(self, remove_outliers=True, price_percentile=90, area_percentile=95):&#10;        self.label_encoders = {}&#10;        self.feature_names = []&#10;        self.target_column = 'price'&#10;        self.remove_outliers = remove_outliers&#10;        self.price_percentile = price_percentile  # More aggressive: 90th percentile&#10;        self.area_percentile = area_percentile     # More aggressive: 95th percentile&#10;        self.price_upper_bound = None&#10;        self.area_upper_bound = None&#10;&#10;    def _clean_price(self, price_str):&#10;        &quot;&quot;&quot;Clean price column - remove RM, commas, etc.&quot;&quot;&quot;&#10;        if pd.isna(price_str):&#10;            return np.nan&#10;        try:&#10;            # Remove everything except digits and decimal points&#10;            cleaned = re.sub(r'[^\d.]', '', str(price_str))&#10;            return float(cleaned) if cleaned else np.nan&#10;        except:&#10;            return np.nan&#10;    &#10;    def _clean_area(self, area_str):&#10;        &quot;&quot;&quot;Clean area column - extract numeric value&quot;&quot;&quot;&#10;        if pd.isna(area_str):&#10;            return np.nan&#10;        try:&#10;            # Remove text and extract first number found&#10;            cleaned = re.sub(r'[^\d.]', '', str(area_str))&#10;            return float(cleaned) if cleaned else np.nan&#10;        except:&#10;            return np.nan&#10;    &#10;    def _parse_location(self, location_str):&#10;        &quot;&quot;&quot;Extract region from location string - simplified to region only&quot;&quot;&quot;&#10;        if pd.isna(location_str):&#10;            return &quot;unknown&quot;&#10;        try:&#10;            # Take the last part as region (most general location)&#10;            parts = str(location_str).split(', ')&#10;            if len(parts) &gt;= 1:&#10;                # Get the last part which is typically the state/region&#10;                region = parts[-1].strip().lower()&#10;                # Clean and standardize region names&#10;                region = re.sub(r'[^\w\s]', '', region)  # Remove special characters&#10;                return region&#10;            else:&#10;                return &quot;unknown&quot;&#10;        except:&#10;            return &quot;unknown&quot;&#10;    &#10;    def _remove_outliers(self, df):&#10;        &quot;&quot;&quot;Remove outliers based on percentiles - more aggressive approach&quot;&quot;&quot;&#10;        if not self.remove_outliers:&#10;            return df&#10;&#10;        print(&quot; Removing outliers with aggressive filtering...&quot;)&#10;        original_size = len(df)&#10;&#10;        # Remove price outliers - more stringent bounds&#10;        if self.target_column in df.columns and self.price_upper_bound is not None:&#10;            print(f&quot;   - Before price outlier removal: {len(df):,} samples&quot;)&#10;            # More stringent price bounds&#10;            df = df[df[self.target_column] &lt;= self.price_upper_bound]&#10;            df = df[df[self.target_column] &gt;= 500]  # Minimum reasonable price RM 500&#10;            df = df[df[self.target_column] &lt;= 8000] # Maximum reasonable price RM 8,000&#10;            print(f&quot;   - After price outlier removal: {len(df):,} samples&quot;)&#10;&#10;        # Remove area outliers - more stringent bounds&#10;        if 'area' in df.columns and self.area_upper_bound is not None:&#10;            print(f&quot;   - Before area outlier removal: {len(df):,} samples&quot;)&#10;            # More stringent area bounds&#10;            df = df[df['area'] &lt;= self.area_upper_bound]&#10;            df = df[df['area'] &gt;= 200]  # Minimum reasonable area 200 sqft&#10;            df = df[df['area'] &lt;= 5000] # Maximum reasonable area 5,000 sqft&#10;            print(f&quot;   - After area outlier removal: {len(df):,} samples&quot;)&#10;&#10;        # Remove unrealistic bedroom/bathroom counts&#10;        if 'bedrooms' in df.columns:&#10;            df = df[df['bedrooms'] &lt;= 6]   # Max 6 bedrooms (more realistic)&#10;            df = df[df['bedrooms'] &gt;= 0]   # Min 0 bedrooms (studio)&#10;&#10;        if 'bathrooms' in df.columns:&#10;            df = df[df['bathrooms'] &lt;= 5]   # Max 5 bathrooms (more realistic)&#10;            df = df[df['bathrooms'] &gt;= 1]   # Min 1 bathroom&#10;&#10;        removed_count = original_size - len(df)&#10;        removal_pct = (removed_count / original_size) * 100&#10;&#10;        print(f&quot;   - Removed {removed_count:,} outliers ({removal_pct:.1f}% of data)&quot;)&#10;        print(f&quot;   - Remaining samples: {len(df):,}&quot;)&#10;&#10;        return df&#10;&#10;    def fit(self, X, y=None):&#10;        &quot;&quot;&quot;Fit the preprocessor on training data&quot;&quot;&quot;&#10;        print(&quot; Fitting preprocessor with aggressive outlier removal...&quot;)&#10;&#10;        # Make a copy of the data&#10;        df = X.copy()&#10;        &#10;        # 1. Clean target variable (price)&#10;        if self.target_column in df.columns:&#10;            df[self.target_column] = df[self.target_column].apply(self._clean_price)&#10;            print(f&quot;   - Price range before cleaning: RM {df[self.target_column].min():,.0f} to RM {df[self.target_column].max():,.0f}&quot;)&#10;&#10;        # 2. Clean area column&#10;        if 'area' in df.columns:&#10;            df['area'] = df['area'].apply(self._clean_area)&#10;            print(f&quot;   - Area range before cleaning: {df['area'].min():.0f} to {df['area'].max():,.0f} sqft&quot;)&#10;&#10;        # 3. Extract region from location - simplified approach&#10;        if 'location' in df.columns:&#10;            df['region'] = df['location'].apply(self._parse_location)&#10;        &#10;        # 4. Calculate outlier bounds before removal&#10;        if self.remove_outliers:&#10;            if self.target_column in df.columns:&#10;                self.price_upper_bound = df[self.target_column].quantile(self.price_percentile / 100)&#10;                print(f&quot;   - Price upper bound (P{self.price_percentile}): RM {self.price_upper_bound:,.0f}&quot;)&#10;&#10;            if 'area' in df.columns:&#10;                self.area_upper_bound = df['area'].quantile(self.area_percentile / 100)&#10;                print(f&quot;   - Area upper bound (P{self.area_percentile}): {self.area_upper_bound:,.0f} sqft&quot;)&#10;&#10;        # 5. Remove outliers&#10;        df = self._remove_outliers(df)&#10;&#10;        # Show final ranges after outlier removal&#10;        if self.target_column in df.columns:&#10;            print(f&quot;   - Final price range: RM {df[self.target_column].min():,.0f} to RM {df[self.target_column].max():,.0f}&quot;)&#10;        if 'area' in df.columns:&#10;            print(f&quot;   - Final area range: {df['area'].min():.0f} to {df['area'].max():,.0f} sqft&quot;)&#10;&#10;        # 6. Ensure proper data types for categorical columns&#10;        categorical_columns = ['property_type', 'furnished', 'region']&#10;        &#10;        for col in categorical_columns:&#10;            if col in df.columns:&#10;                # Fill missing values with 'unknown'&#10;                df[col] = df[col].fillna('unknown').astype(str)&#10;                &#10;                # Fit label encoder&#10;                self.label_encoders[col] = LabelEncoder()&#10;                self.label_encoders[col].fit(df[col])&#10;                &#10;                print(f&quot;   - {col}: {len(self.label_encoders[col].classes_)} categories&quot;)&#10;        &#10;        # 7. Store feature names (excluding target and original location)&#10;        self.feature_names = [col for col in ['property_type', 'bedrooms', 'bathrooms',&#10;                                            'area', 'furnished', 'region'] &#10;                             if col in df.columns]&#10;        &#10;        print(f&quot;   - Features selected: {self.feature_names}&quot;)&#10;        return self&#10;    &#10;    def transform(self, X, y=None):&#10;        &quot;&quot;&quot;Transform the data&quot;&quot;&quot;&#10;        print(&quot; Transforming data...&quot;)&#10;        &#10;        # Make a copy&#10;        df = X.copy()&#10;        &#10;        # 1. Clean price if present&#10;        if self.target_column in df.columns:&#10;            df[self.target_column] = df[self.target_column].apply(self._clean_price)&#10;        &#10;        # 2. Clean area&#10;        if 'area' in df.columns:&#10;            df['area'] = df['area'].apply(self._clean_area)&#10;        &#10;        # 3. Extract region from location - simplified&#10;        if 'location' in df.columns:&#10;            df['region'] = df['location'].apply(self._parse_location)&#10;        &#10;        # 4. Remove outliers (only during training when target is present)&#10;        if self.target_column in df.columns:  # This indicates training data&#10;            df = self._remove_outliers(df)&#10;&#10;        # 5. Encode categorical variables&#10;        for col, encoder in self.label_encoders.items():&#10;            if col in df.columns:&#10;                # Fill missing values and ensure string type&#10;                df[col] = df[col].fillna('unknown').astype(str)&#10;                &#10;                # Handle unknown categories&#10;                mask = df[col].isin(encoder.classes_)&#10;                df.loc[~mask, col] = 'unknown' if 'unknown' in encoder.classes_ else encoder.classes_[0]&#10;                &#10;                # Transform&#10;                df[col] = encoder.transform(df[col])&#10;        &#10;        # 6. Select only the features we want&#10;        result = df[self.feature_names + ([self.target_column] if self.target_column in df.columns else [])].copy()&#10;        &#10;        # 7. Handle missing values&#10;        # For numerical columns, fill with median&#10;        numerical_cols = ['bedrooms', 'bathrooms', 'area']&#10;        for col in numerical_cols:&#10;            if col in result.columns:&#10;                result[col] = pd.to_numeric(result[col], errors='coerce')&#10;                median_val = result[col].median()&#10;                result[col] = result[col].fillna(median_val)&#10;        &#10;        # 8. Remove rows with missing target variable (for training)&#10;        if self.target_column in result.columns:&#10;            result = result.dropna(subset=[self.target_column])&#10;        &#10;        # 9. Remove rows with too many missing features&#10;        feature_cols = [col for col in self.feature_names if col in result.columns]&#10;        result = result.dropna(subset=feature_cols)&#10;        &#10;        print(f&quot;   - Final shape: {result.shape}&quot;)&#10;        print(f&quot;   - Features: {[col for col in result.columns if col != self.target_column]}&quot;)&#10;        &#10;        return result" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>